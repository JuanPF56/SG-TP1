<!doctype html>
<html>
    <head>
        <title></title>        
        <style>
            body{ background-color: grey; }
            canvas{ background-color: white; }
			textarea{ background-color: black; foreground-color: white;}
        </style>
    </head>
    <body>

    	<center>    		            
            <canvas id="my-canvas" width="1000" height="800">
            	Your browser does not support the HTML5 canvas element.
    		</canvas>    		
    	</center>

        <script type="text/javascript" src="js/gl-matrix.js"></script>
        <script type="text/javascript" src="js/jquery.min.js"></script>
        
        <script id="shader-vs" type="x-shader/x-vertex">

            precision highp float;

            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal;

            uniform mat4 modelMatrix;            
            uniform mat4 viewMatrix;
            uniform mat4 projMatrix;

            uniform mat4 normalMatrix;

            varying vec3 vNormal;    
            varying vec3 vPosWorld;  

            void main(void) {
                gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(aVertexPosition, 1.0);

                vPosWorld=(modelMatrix*vec4(aVertexPosition,1.0)).xyz;    //la posicion en coordenadas de mundo
                vNormal=(normalMatrix*vec4(aVertexNormal,1.0)).xyz;       //la normal en coordenadas de mundo                
                
            }
        </script>

        <script id="shader-fs" type="x-shader/x-fragment">
            precision highp float;
            varying vec3 vNormal;
            varying vec3 vPosWorld;

            void main(void) {

                vec3 lightVec=normalize(vec3(0.0,3.0,5.0)-vPosWorld);
                vec3 diffColor=mix(vec3(0.7,0.7,0.7),vNormal,0.4);
                vec3 color=dot(lightVec,vNormal)*diffColor+vec3(0.2,0.2,0.2);

               gl_FragColor = vec4(color,1.0);
            }
        </script>

        <script type="text/javascript" src="js/curves.js"></script>
        <script type="text/javascript" src="js/surfaces.js"></script>
        <script type="text/javascript" src="js/objects.js"></script>

        <!-- Puntos de control extraÃ­dos de los archivos SVG -->

        <path id="terrenoPath" d="M -18.919 75.676 C -18.919 75.676 94.595 75.676 123.917 75.676 C 132.433 75.676 132.433 56.757 140.085 56.757 C 208.109 56.757 500.751 56.757 500.751 56.757"/>
        <path id="torrePath" d="M 0 52.251 L 81.68 52.251 L 81.68 20.42 L 102.1 20.42 C 102.1 20.42 102.1 61.26 102.1 81.68 C 102.1 103.205 81.68 102.1 81.68 142.94 C 81.68 183.78 142.94 305.999 142.94 398.341 C 142.94 418.761 142.94 458.375 142.94 458.375"/>
        <path id="murallaPath" d="M 0 268.216 C 0 167.635 33.527 100.581 33.527 33.527 L 33.527 0 L 67.054 0 L 67.054 33.527 L 134.108 33.527 L 201.162 33.527 L 201.162 0 L 234.689 0 L 234.689 33.527 C 234.689 100.581 268.216 167.635 268.216 268.216 Z"/>
        <path id="torreCPath" d="M 0 0 L 61.746 0 C 61.746 0 61.594 81.68 61.594 122.52 C 61.594 135.432 41.52 141.9 41.174 163.36 C 40.423 209.907 41.174 449.24 41.174 449.24"/>
        <path id="techoTCPath" d="M 0 0 C 0 0 0.009 84.835 72.081 141.892 C 31.241 141.892 0 141.891 0 141.891"/>
        <path id="ventanaPath" d="M 0 150 L 0 50 C 0 35 10 0 50 0 C 90 0 100 35 100 50 C 100 100 100 150 100 150 L 0 150 Z"/>
        <path id="circuloPath" d="M 200 100 C 200 155.228 155.228 200 100 200 C 44.771 200 0 155.228 0 100 C 0 44.771 44.771 0 100 0 C 155.228 0 200 44.771 200 100 Z"/>
        <path id="cuadradoPath" d="M 0 100 C 0 100 0 0 0 0 C 0 0 100 0 100 0 L 100 100 L 0 100 Z"/>
        <path id="plataformaPath" d="M 0 56.757 C 0 56.757 37.838 56.757 75.676 56.757 C 89.778 56.757 94.595 75.676 94.595 75.676"/>
        
        <script>


            var mat4=glMatrix.mat4;
            var vec2=glMatrix.vec2;
            var vec3=glMatrix.vec3;
            var vec4=glMatrix.vec4;

            var gl = null,
            canvas = null,

            glProgram = null,
            fragmentShader = null,
            vertexShader = null;
                
            var vertexPositionAttribute = null,
            trianglesVerticeBuffer = null,
            vertexNormalAttribute = null,
            trianglesNormalBuffer = null,
            trianglesIndexBuffer = null;
               
            var modelMatrix = mat4.create();
            var viewMatrix = mat4.create();
            var projMatrix = mat4.create();
            var normalMatrix = mat4.create();

            var previousClientX = 0;
            var previousClientY = 0;
            var ratio = 5;
            var alpha = 0;
            var beta = Math.PI/2;
            var speedFactor = 0.01;
            var t = 0;

            var isMouseDown = false;
            var actualEvent;

            var mouse = {x: 0, y: 0};

            $('body').mousemove(function(e){ 
                mouse.x = e.clientX || e.pageX; 
                mouse.y = e.clientY || e.pageY 
            });
            
            $('body').mousedown(function(event){       
                isMouseDown = true;        
            });

            $('body').mouseup(function(event){
                isMouseDown = false;        
            });     

            $('body').bind('mousewheel DOMMouseScroll', function(event){
                if(event.originalEvent.wheelDelta < 0){
                    ratio += 0.5;
                }else if (ratio > 1){
                    ratio -= 0.5;
                }
            });   

         
            function initWebGL(){

                canvas = document.getElementById("my-canvas");  

                try{
                    gl = canvas.getContext("webgl");      

                }catch(e){
                    alert(  "Error: Your browser does not appear to support WebGL.");
                }

                if(gl) {
                    setupWebGL();
                    initShaders();
                    setupVertexShaderMatrix();
                    tick();   

                }else{    
                    alert(  "Error: Your browser does not appear to support WebGL.");
                }

            }
           

            function setupWebGL(){

                gl.enable(gl.DEPTH_TEST);

                //set the clear color

                gl.clearColor(0.1, 0.1, 0.2, 1.0);     
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);     
    
                gl.viewport(0, 0, canvas.width, canvas.height);

                // Matrix de Proyeccion Perspectiva

                mat4.perspective(projMatrix,45, canvas.width / canvas.height, 0.1, 100.0);
                
                mat4.identity(modelMatrix);
                mat4.identity(viewMatrix);

            }
                    
                    
            function initShaders() {
                //get shader source
                var fs_source = document.getElementById('shader-fs').innerHTML,
                    vs_source = document.getElementById('shader-vs').innerHTML;

                //compile shaders    
                vertexShader = makeShader(vs_source, gl.VERTEX_SHADER);
                fragmentShader = makeShader(fs_source, gl.FRAGMENT_SHADER);
                
                //create program
                glProgram = gl.createProgram();
                
                //attach and link shaders to the program
                gl.attachShader(glProgram, vertexShader);
                gl.attachShader(glProgram, fragmentShader);
                gl.linkProgram(glProgram);

                if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
                    alert("Unable to initialize the shader program.");
                }
                
                //use program
                gl.useProgram(glProgram);
            }
            
            function makeShader(src, type){
                //compile the vertex shader
                var shader = gl.createShader(type);
                gl.shaderSource(shader, src);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.log("Error compiling shader: " + gl.getShaderInfoLog(shader));
                }
                return shader;
            }


            function setupVertexShaderMatrix(){
                var modelMatrixUniform = gl.getUniformLocation(glProgram, "modelMatrix");
                var viewMatrixUniform  = gl.getUniformLocation(glProgram, "viewMatrix");
                var projMatrixUniform  = gl.getUniformLocation(glProgram, "projMatrix");
                var normalMatrixUniform  = gl.getUniformLocation(glProgram, "normalMatrix");

                gl.uniformMatrix4fv(modelMatrixUniform, false, modelMatrix);
                gl.uniformMatrix4fv(viewMatrixUniform, false, viewMatrix);
                gl.uniformMatrix4fv(projMatrixUniform, false, projMatrix);
                gl.uniformMatrix4fv(normalMatrixUniform, false, normalMatrix);
            } 
        
            function readSVGpath(name){

                var parser = new DOMParser();
                var path = document.getElementById(name+"Path").getAttribute("d");

                var pointData = path.split(' ');
                var controlPoints = [];

                for(var i=1; i < pointData.length; i++){
                    if(pointData[i] == "L"){
                        controlPoints.push([pointData[i-2]/100,-pointData[i-1]/100]);
                        controlPoints.push([pointData[i-2]/100,-pointData[i-1]/100]);
                        controlPoints.push([pointData[i+1]/100,-pointData[i+2]/100]);
                    }
                    else if(pointData[i] == "C"){
                        controlPoints.push([pointData[i-2]/100,-pointData[i-1]/100]);
                        controlPoints.push([pointData[i+1]/100,-pointData[i+2]/100]);
                        controlPoints.push([pointData[i+3]/100,-pointData[i+4]/100]);
                    }
                    else if((i == pointData.length - 3) && (pointData[pointData.length - 1] != "Z")){
                        controlPoints.push([pointData[i+1]/100,-pointData[i+2]/100]);
                    } 
                    else if (pointData[i] == "Z"){                        
                        controlPoints.push([pointData[i-2]/100,-pointData[i-1]/100]);
                        controlPoints.push([pointData[i-2]/100,-pointData[i-1]/100]);
                        controlPoints.push([pointData[1]/100,-pointData[2]/100]);
                        controlPoints.push([pointData[1]/100,-pointData[2]/100]);
                    }
                }

                return controlPoints;

            }

            function drawCastle(){

                techo1 = new Roof();
                techo1.translate(0,0,4.5);

                techo2 = new Roof();
                techo2.translate(0,0,4.5);

                techo3 = new Roof();
                techo3.translate(0,0,4.5);

                techo4 = new Roof();
                techo4.translate(0,0,4.5);

                torreC1 = new TowerC([techo1]);
                torreC1.translate(0.4,0.25,-0.3);
                torreC1.scale(0.15);

                torreC2 = new TowerC([techo2]);
                torreC2.translate(-0.4,0.25,-0.3);
                torreC2.scale(0.15);

                torreC3 = new TowerC([techo3]);           
                torreC3.translate(0.4,-0.25,-0.3);
                torreC3.scale(0.15);

                torreC4 = new TowerC([techo4]);
                torreC4.translate(-0.4,-0.25,-0.3);
                torreC4.scale(0.15);

                bloqueD1 = new Block(0.02,0.02,0.75);
                bloqueD1.translate(0,0.25,0);

                bloqueD2 = new Block(0.02,0.02,0.75);
                bloqueD2.translate(0,-0.25,0);

                bloqueD3 = new Block(0.02,0.02,0.5);
                bloqueD3.rotateZ(Math.PI/2);
                bloqueD3.translate(0,0.375,0);

                bloqueD4 = new Block(0.02,0.02,0.5);
                bloqueD4.rotateZ(Math.PI/2);
                bloqueD4.translate(0,-0.375,0);

                ventana1 = new Window(0.08,0.08,0.525,0,0);
                ventana1.rotateZ(Math.PI/2);
                ventana1.translate(0,0,0.12);
                ventana2 = new Window(0.08,0.08,0.525,0,0);
                ventana2.rotateZ(Math.PI/2);
                ventana2.translate(0,-0.2,0.12);
                ventana3 = new Window(0.08,0.08,0.525,0,0);
                ventana3.rotateZ(Math.PI/2);
                ventana3.translate(0,0.2,0.12);

                ventana4 = new Window(0.08,0.08,0.525,0,0);
                ventana4.rotateZ(Math.PI/2);
                ventana4.translate(0,0,-0.12);
                ventana5 = new Window(0.08,0.08,0.525,0,0);
                ventana5.rotateZ(Math.PI/2);
                ventana5.translate(0,-0.2,-0.12);
                ventana6 = new Window(0.08,0.08,0.525,0,0);
                ventana6.rotateZ(Math.PI/2);
                ventana6.translate(0,0.2,-0.12);

                ventana7 = new Window(0.08,0.08,0.78,0,0);
                ventana7.translate(0,0.08,0.12);
                ventana8 = new Window(0.08,0.08,0.78,0,0);
                ventana8.translate(0,-0.08,0.12);

                ventana9 = new Window(0.08,0.08,0.78,0,0);
                ventana9.translate(0,0.08,-0.12);
                ventana10 = new Window(0.08,0.08,0.78,0,0);
                ventana10.translate(0,-0.08,-0.12);

                castillo = new Block(0.6,0.5,0.75,0,0,[torreC1,torreC2,torreC3,torreC4,bloqueD1,bloqueD2,bloqueD3,bloqueD4,ventana1,ventana2,ventana3,ventana4,ventana5,ventana6,ventana7,ventana8,ventana9,ventana10]);

                castillo.translate(0,0,0.4);
                castillo.scale(0.75);

                return castillo;
            }

            function drawWalls(){

                torre1 = new Tower();
                torre2 = new Tower();
                torre3 = new Tower();
                torre4 = new Tower();
                torre5 = new Tower();
                torre6 = new Tower();
                torre7 = new Tower();
                torre8 = new Tower();

                torre1.translate(3,-6,0);
                torre1.scale(0.7);
                torre2.translate(-3,-6,0);
                torre2.scale(0.7);
                torre3.translate(-6,-3,0);
                torre3.scale(0.7);
                torre4.translate(-6,3,0);
                torre4.scale(0.7);
                torre5.translate(-3,6,0);
                torre5.scale(0.7);
                torre6.translate(3,6,0);
                torre6.scale(0.7);
                torre7.translate(6,3,0);
                torre7.scale(0.7);
                torre8.translate(6,-3,0);
                torre8.scale(0.7);

                muralla1 = new Wall(6,0,0);
                muralla2 = new Wall(10,0,0);
                muralla3 = new Wall(6,0,0);
                muralla4 = new Wall(10,0,0);
                muralla5 = new Wall(6,0,0);
                muralla6 = new Wall(10,0,0);
                muralla7 = new Wall(6,0,0);

                muralla1.translate(4.5,-4.5,0.75);
                muralla1.rotateZ(Math.PI/4);
                muralla1.scale(0.6);

                muralla2.translate(6,0,0.75);
                muralla2.rotateZ(Math.PI/2);
                muralla2.scale(0.6);

                muralla3.translate(4.5,4.5,0.75);
                muralla3.rotateZ(Math.PI*3/4);
                muralla3.scale(0.6);

                muralla4.translate(0,6,0.75);
                muralla4.rotateZ(Math.PI);
                muralla4.scale(0.6);

                muralla5.translate(-4.5,4.5,0.75);
                muralla5.rotateZ(Math.PI*5/4);
                muralla5.scale(0.6);

                muralla6.translate(-6,0,0.75);
                muralla6.rotateZ(-Math.PI/2);
                muralla6.scale(0.6);

                muralla7.translate(-4.5,-4.5,0.75);
                muralla7.rotateZ(-Math.PI/4);
                muralla7.scale(0.6);

                murallaP1 = new Wall(2.5,0,0);
                murallaP1.translate(3,0,0);
                murallaP2 = new Wall(2.5,0,0);
                murallaP2.translate(-3,0,0);
                bloqueP1 = new Block(0.2,3,3.5,0.01,0);
                bloqueP1.translate(1.8,0,0);
                bloqueP1.rotateY(Math.PI/2);
                bloqueP2 = new Block(0.2,3,3.5,0.01,0);
                bloqueP2.translate(-1.8,0,0);
                bloqueP2.rotateY(Math.PI/2);
                bloqueP3 = new Block(0.2,3,3.8,0,0);
                bloqueP3.translate(0,0,1.8);
                bloquePuerta = new Block(0.2,2.5,3.4,0,0);
                bloquePuerta.translate(0,-1,0);
                bloquePuerta.translate(0,0,-1);
                bloquePuerta.rotateX(Math.PI*((Math.sin(t))*1/4+1/4));
                bloquePuerta.translate(0,0,1);
                bloquePuerta.rotateX(Math.PI/2);

                puerta = new Transformable([murallaP1,murallaP2,bloqueP1,bloqueP2,bloqueP3,bloquePuerta]);
                puerta.translate(0,-6,0.8);
                puerta.scale(0.6);

                pared = new Transformable([torre1,torre2,torre3,torre4,torre5,torre6,torre7,torre8,muralla1,muralla2,muralla3,muralla4,muralla5,muralla6,muralla7,puerta]);

                pared.translate(0,0,0.18);
                pared.scale(0.1);

                return pared;

            }

            function drawCatapult(){

                municion = new Sphere();
                municion.scale(0.4);
                municion.translate(0,0,1.2);

                cabeza = new Block(0.2,1.2,1.2,0,0,[municion]);
                cabeza.translate(-2.5,0,0.15);

                sostenCP1 = new Block(0.03,0.2,0.4,0.01,0);
                sostenCP1.translate(0.2,0,-0.1);
                sostenCP1.rotateY(Math.PI/2);
                sostenCP2 = new Block(0.03,0.2,0.4,0.01,0);
                sostenCP2.translate(-0.2,0,-0.1);
                sostenCP2.rotateY(Math.PI/2);
                contraPeso = new Block(0.4,0.6,0.6,0,0);
                contraPeso.translate(0,0,-0.5);

                ejeCP = new Cylinder(0.08,0.08,0.5,0,0,[sostenCP1,sostenCP2,contraPeso]);
                ejeCP.translate(2.8,0,0);
                ejeCP.rotateZ(Math.PI/2);
                ejeCP.rotateX(-Math.PI*((Math.sin(t*20))*1/4+1/8));

                pala = new Block(0.2,0.2,6,0.03,0, [ejeCP, cabeza]);
                pala.translate(0,1.6,0.2);
                pala.rotateZ(-Math.PI/2);

                ejeP = new Cylinder(0.25,0.25,2,0,0, [pala]);
                ejeP.translate(0,0,0.7);
                ejeP.rotateZ(Math.PI/2);
                ejeP.rotateX(Math.PI*((Math.sin(t*20))*1/4+1/8));
                sosten1 = new Block(0.1,0.7,2.4,0.05,0);
                sosten1.translate(0,0.8,0);
                sosten1.rotateY(Math.PI/2);
                sosten1.rotateX(Math.PI/2);
                sosten2 = new Block(0.1,0.7,2.4,0.05,0);
                sosten2.translate(0,-0.8,0);
                sosten2.rotateY(Math.PI/2);
                sosten2.rotateX(Math.PI/2);
                sosten = new Transformable([sosten1,sosten2,ejeP]);
                sosten.translate(0.6,0,1.2);

                ruedaD1 = new Cylinder(0.4,0.4,0.15,0,0);
                ruedaD1.translate(1.35,0,0);
                ruedaD2 = new Cylinder(0.4,0.4,0.15,0,0);
                ruedaD2.translate(-1.35,0,0);
                ejeD = new Cylinder(0.05,0.05,3,0,0, [ruedaD1,ruedaD2]);
                ejeD.translate(1.2,0,0);
                ejeD.rotateZ(Math.PI/2);

                ruedaT1 = new Cylinder(0.4,0.4,0.15,0,0);
                ruedaT1.translate(1.35,0,0);
                ruedaT2 = new Cylinder(0.4,0.4,0.15,0,0);
                ruedaT2.translate(-1.35,0,0);
                ejeT = new Cylinder(0.05,0.05,3,0,0, [ruedaT1,ruedaT2]);
                ejeT.translate(-1.2,0,0);
                ejeT.rotateZ(Math.PI/2);



                catapulta = new Block(0.2,2.5,3.5,0,0,[ejeD,ejeT,sosten]);
                catapulta.rotateZ(Math.PI*t/10);
                catapulta.translate(1.5,1.5,0.03);
                catapulta.rotateZ(Math.PI*5/4);
                catapulta.scale(0.06);

                return catapulta;

            }
            
            function drawScene(){

                setupVertexShaderMatrix();
                controls();

                t +=0.01;

                agua = new Plane();
                agua.translate(0,0,-0.1);
                agua.rotateX(-Math.PI/2);

                puente = new Block(0.2,2,4,0,0);
                puente.scale(0.15);
                puente.rotateZ(Math.PI/2);
                puente.translate(-6.5,0,0.8);

                plataforma = new Platform([drawCastle(),drawWalls(),puente]);
                plataforma.scale(1.1);
                plataforma.translate(0,0,-0.2);


                terreno = new Terrain([agua]);
                terreno.rotateZ(Math.PI*22.5/180);
                scene = new Transformable([terreno,plataforma,drawCatapult()]);


                scene.draw(mat4.create(),mat4.create());
            }

 

            function controls(){

                var deltaX=0;
                var deltaY=0;

                if(isMouseDown){

                    if (previousClientX) deltaX = mouse.x - previousClientX;
                    if (previousClientY) deltaY = mouse.y - previousClientY;

                    previousClientX = mouse.x;
                    previousClientY = mouse.y;

                    alpha = alpha + deltaX * speedFactor;
                    beta = beta + deltaY * speedFactor;

                    if (beta>Math.PI/2) beta=Math.PI/2;
                    if (beta<0) beta=0;

                    
                    $('#valorDeltaX').html(deltaX);
                    $('#valorDeltaY').html(deltaY);

                    $('#valorAlpha').html(alpha.toFixed(2));
                    $('#valorBeta').html(beta.toFixed(2));

                }

                mat4.identity(viewMatrix);
                mat4.translate(viewMatrix,viewMatrix,[0,0, -ratio]);
                mat4.rotateX(viewMatrix,viewMatrix, -beta);
                mat4.rotateZ(viewMatrix,viewMatrix, alpha);

                mat4.identity(normalMatrix);
                mat4.multiply(normalMatrix,viewMatrix,modelMatrix);
                mat4.invert(normalMatrix,normalMatrix);
                mat4.transpose(normalMatrix,normalMatrix);

            }
            
            function tick(){

                requestAnimationFrame(tick);
                drawScene();

            }

            window.onload=initWebGL;

        </script>


    </body>
</html>
