<!doctype html>
<html>
    <head>
        <title></title>        
        <style>
            body{ background-color: grey; }
            canvas{ background-color: white; }
			textarea{ background-color: black; foreground-color: white;}
        </style>
    </head>
    <body>

    	<center>    		            
            <canvas id="my-canvas" width="1000" height="800">
            	Your browser does not support the HTML5 canvas element.
    		</canvas>    		
    	</center>

        <script type="text/javascript" src="js/gl-matrix.js"></script>
        <script type="text/javascript" src="js/jquery.min.js"></script>
        <script type="text/javascript" src="js/dat.gui.js"></script>
        
        <script id="shader-vs" type="x-shader/x-vertex">

            precision highp float;

            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal;
            attribute vec3 aVertexColor;
            attribute vec2 aVertexUv;

            uniform mat4 modelMatrix;            
            uniform mat4 viewMatrix;
            uniform mat4 projMatrix;

            uniform mat4 normalMatrix;

            varying vec3 vNormal;    
            varying vec3 vPosWorld;  
            varying highp vec3 vColor;
            varying highp vec2 vUv;

            void main(void) {

                gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(aVertexPosition, 1.0);

                vPosWorld=(modelMatrix*vec4(aVertexPosition,1.0)).xyz;
                vNormal=(normalMatrix*vec4(aVertexNormal,1.0)).xyz; 
                vColor = aVertexColor;
                vUv = aVertexUv;
                
            }
        </script>

        <script id="shader-fs-normals" type="x-shader/x-fragment">

            precision highp float;
            varying vec3 vNormal;
            varying vec3 vPosWorld;

            void main(void) {

                vec3 lightVec=normalize(vec3(0.0,3.0,5.0)-vPosWorld);
                vec3 diffColor=mix(vec3(0.7,0.7,0.7),vNormal,0.4);
                vec3 color=dot(lightVec,vNormal)*diffColor+vec3(0.2,0.2,0.2);
                gl_FragColor = vec4(color,1.0);

            }
        </script>

        <script id="shader-fs-colors" type="x-shader/x-fragment">

            precision highp float;
            varying vec3 vNormal;
            varying vec3 vPosWorld;
            varying highp vec3 vColor;

            void main(void) {

                vec3 lightVec=normalize(vec3(0.0,3.0,5.0)-vPosWorld);
                vec3 color=dot(lightVec,vNormal)*vColor+vec3(0.2,0.2,0.2);
                gl_FragColor = vec4(color,1.0);

            }
        </script>

        <script id="shader-fs-textures" type="x-shader/x-fragment">

            precision highp float;
            varying vec3 vNormal;
            varying vec3 vPosWorld;
            varying highp vec3 vColor;
            varying highp vec2 vUv;
            uniform sampler2D uSampler;
            
            void main(void) {
               vec4 textureColor = texture2D(uSampler,vUv);
               gl_FragColor = vec4(textureColor.xyz,1.0);
            }

        </script>


        <script type="text/javascript" src="js/curves.js"></script>
        <script type="text/javascript" src="js/surfaces.js"></script>
        <script type="text/javascript" src="js/objects.js"></script>

        <!-- Puntos de control extraÃ­dos de los archivos SVG -->

        <path id="terrenoPath" d="M -18.919 75.676 C -18.919 75.676 94.595 75.676 123.917 75.676 C 132.433 75.676 132.433 56.757 140.085 56.757 C 208.109 56.757 500.751 56.757 500.751 56.757"/>
        <path id="torrePath" d="M 0 52.251 L 81.68 52.251 L 81.68 20.42 L 102.1 20.42 C 102.1 20.42 102.1 61.26 102.1 81.68 C 102.1 103.205 81.68 102.1 81.68 142.94 C 81.68 183.78 142.94 305.999 142.94 398.341 C 142.94 418.761 142.94 458.375 142.94 458.375"/>
        <path id="murallaPath" d="M 0 268.216 C 0 167.635 33.527 100.581 33.527 33.527 L 33.527 0 L 67.054 0 L 67.054 33.527 L 134.108 33.527 L 201.162 33.527 L 201.162 0 L 234.689 0 L 234.689 33.527 C 234.689 100.581 268.216 167.635 268.216 268.216 Z"/>
        <path id="torreCPath" d="M 0 0 L 61.746 0 C 61.746 0 61.594 81.68 61.594 122.52 C 61.594 135.432 41.52 141.9 41.174 163.36 C 40.423 209.907 41.174 449.24 41.174 449.24"/>
        <path id="techoTCPath" d="M -0.426 0.077 C -0.426 0.077 3.931 4.647 9.101 20.497 C 40.414 116.496 81.254 135.925 81.254 143.017 C 81.254 148.347 -0.426 143.017 -0.426 143.017"/>
        <path id="ventanaPath" d="M 0 150 L 0 50 C 0 35 10 0 50 0 C 90 0 100 35 100 50 C 100 100 100 150 100 150 L 0 150 Z"/>
        <path id="circuloPath" d="M 200 100 C 200 155.228 155.228 200 100 200 C 44.771 200 0 155.228 0 100 C 0 44.771 44.771 0 100 0 C 155.228 0 200 44.771 200 100 Z"/>
        <path id="cuadradoPath" d="M 0 100 C 0 100 0 0 0 0 C 0 0 100 0 100 0 L 100 100 L 0 100 Z"/>
        <path id="plataformaPath" d="M 0 56.757 C 0 56.757 37.838 56.757 75.676 56.757 C 89.778 56.757 94.595 75.676 94.595 75.676"/>
        
        <script>


            var mat4=glMatrix.mat4;
            var vec2=glMatrix.vec2;
            var vec3=glMatrix.vec3;
            var vec4=glMatrix.vec4;

            var gl = null,
            canvas = null,

            glProgram = null,
            fragmentShader = null,
            vertexShader = null;
                
            var vertexPositionAttribute = null,
            trianglesVerticeBuffer = null,
            vertexNormalAttribute = null,
            trianglesNormalBuffer = null,
            vertexColorAttribute = null,
            trianglesColorBuffer = null,
            vertexUVAttribute = null,
            trianglesUVBuffer = null,
            trianglesIndexBuffer = null;
               
            var modelMatrix = mat4.create();
            var viewMatrix = mat4.create();
            var projMatrix = mat4.create();
            var normalMatrix = mat4.create();

            var textures = [];

            var previousClientX = 0;
            var previousClientY = 0;
            var ratio = 5;
            var alpha = 0;
            var beta = Math.PI/2;
            var speedFactor = 0.01;
            var scrollSpeed = 0.5;

            var t = 0;
            var anim = 10; 
            var loaded = 1;
            var s = 0;
            var shot = 0;
            var start;
            var end;

            const options = {

                pisos: 2,
                ancho: 0.6,
                largo: 0.6,
                ladosMuralla: 8,
                alturaMuralla: 1,
                anguloPuerta: 0,
                rotacionCatapulta: 180,
                ubicacionCatapulta: 0,
                camara: 1,
                renderizado: 0

            }

            var camera = 1;
            var renderType = 0;

            const windowSeparation = 0.1;

            var castleFloors = 2;
            var castleWidth = 0.6;
            var castleLength = 0.6;
            var wallSides = 8;
            var wallHeight = 1;

            var gateAngle = 0;
            var catapultRot = 180;
            var catapultPos = 0;

            var isMouseDown = false;
            var actualEvent;

            var mouse = {x: 0, y: 0};

            var fpPosition = {x: 0, y: 0};
            var fpRotation = {z: 0};

            $('canvas').mousemove(function(e){ 
                mouse.x = e.clientX || e.pageX; 
                mouse.y = e.clientY || e.pageY 
            });
            
            $('canvas').mousedown(function(event){       
                isMouseDown = true;        
            });

            $('canvas').mouseup(function(event){
                isMouseDown = false;        
            });     

            $('canvas').bind('mousewheel DOMMouseScroll', function(event){
                if(event.originalEvent.wheelDelta < 0){
                    ratio += scrollSpeed;
                }else if (ratio > 1){
                    ratio -= scrollSpeed;
                }
            });   

            $('body').on("keydown",function(event){
            switch(event.key){
                case "1":
                    ratio = 4;
                    scrollSpeed = 0.5;
                    camera = 1;
                    options.camara = 1;
                break;
                case "2":
                    ratio = 20;                        
                    scrollSpeed = 5;
                    camera = 2;
                    options.camara = 2;
                break;
                case "3":
                    camera = 3;
                    options.camara = 3;
                break;
                case "a":
                    fpPosition.x+=right[0];
                    fpPosition.y+=right[1];
                break;
                case "d":
                    fpPosition.x-=right[0];
                    fpPosition.y-=right[1];
                break;
                case "w":
                    fpPosition.x-=forward[0];
                    fpPosition.y-=forward[1];
                break;  
                case "s":
                    fpPosition.x+=forward[0];
                    fpPosition.y+=forward[1];
                break;
                case "q":
                    fpRotation.z-=0.1;
                break; 
                case "e":
                    fpRotation.z+=0.1;
                break;                                             
            }
                 
            });    


         
            function initWebGL(){

                canvas = document.getElementById("my-canvas");  

                try{
                    gl = canvas.getContext("webgl");      

                }catch(e){
                    alert(  "Error: Your browser does not appear to support WebGL.");
                }

                if(gl) {
                    initTextures();
                    setupWebGL();
                    initShaders();
                    initMenu();
                    setupVertexShaderMatrix();
                    tick();   

                }else{    
                    alert(  "Error: Your browser does not appear to support WebGL.");
                }

            }

            function loadTextureStep2(image, texture, clamp, flip) {

                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flip);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);

                if (clamp) {
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                }

                gl.generateMipmap(gl.TEXTURE_2D);
                gl.bindTexture(gl.TEXTURE_2D, null);

            }
            
    
            function loadTexture(path, clamp=false, flip=false) {

                var texture = gl.createTexture();
                var image = new Image();

                image.onload = function() {
                    loadTextureStep2(image, texture, clamp, flip);
                }

                image.src = path;
                
                return texture;

            }

            function initTextures(){
            
                textures["uvGrid"] = loadTexture("img/uv.jpg",false,false);

                textures["brick"] = loadTexture("img/brick.png",false,false);

                textures["wood"] = loadTexture("img/wood.png",false,true);

                textures["marble"] = loadTexture("img/marble.png",false,true);

                textures["grass"] = loadTexture("img/grass.png",false,true);

                textures["stone"] = loadTexture("img/stone.png",false,true);

                textures["tiles"] = loadTexture("img/tiles.png",false,true);

                textures["glass"] = loadTexture("img/glass.png",false,true);

                textures["water"] = loadTexture("img/water.png",false,true);

            }
           

            function setupWebGL(){

                gl.enable(gl.DEPTH_TEST);

                //set the clear color

                gl.clearColor(0.1, 0.1, 0.2, 1.0);     
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);     
    
                gl.viewport(0, 0, canvas.width, canvas.height);

                // Matrix de Proyeccion Perspectiva

                mat4.perspective(projMatrix,45, canvas.width / canvas.height, 0.1, 100.0);
                
                mat4.identity(modelMatrix);
                mat4.identity(viewMatrix);

            }
                    
                    
            function initShaders() {

                if(renderType == 0) {var fs_source = document.getElementById('shader-fs-textures').innerHTML;}
                else if(renderType == 2) {var fs_source = document.getElementById('shader-fs-normals').innerHTML;}
                else {var fs_source = document.getElementById('shader-fs-colors').innerHTML;}
                var vs_source = document.getElementById('shader-vs').innerHTML;

                //compile shaders    
                vertexShader = makeShader(vs_source, gl.VERTEX_SHADER);
                fragmentShader = makeShader(fs_source, gl.FRAGMENT_SHADER);
                
                //create program
                glProgram = gl.createProgram();
                
                //attach and link shaders to the program
                gl.attachShader(glProgram, vertexShader);
                gl.attachShader(glProgram, fragmentShader);
                gl.linkProgram(glProgram);

                if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
                    alert("Unable to initialize the shader program.");
                }
                
                //use program
                gl.useProgram(glProgram);

                if(renderType == 0) {glProgram.samplerUniform = gl.getUniformLocation(glProgram, "uSampler");}

            }
            
            function makeShader(src, type){
                //compile the vertex shader
                var shader = gl.createShader(type);
                gl.shaderSource(shader, src);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.log("Error compiling shader: " + gl.getShaderInfoLog(shader));
                }
                return shader;
            }


            function setupVertexShaderMatrix(){
                var modelMatrixUniform = gl.getUniformLocation(glProgram, "modelMatrix");
                var viewMatrixUniform  = gl.getUniformLocation(glProgram, "viewMatrix");
                var projMatrixUniform  = gl.getUniformLocation(glProgram, "projMatrix");
                var normalMatrixUniform  = gl.getUniformLocation(glProgram, "normalMatrix");

                gl.uniformMatrix4fv(modelMatrixUniform, false, modelMatrix);
                gl.uniformMatrix4fv(viewMatrixUniform, false, viewMatrix);
                gl.uniformMatrix4fv(projMatrixUniform, false, projMatrix);
                gl.uniformMatrix4fv(normalMatrixUniform, false, normalMatrix);
            } 

            function initMenu(){

                var gui = new dat.GUI();

                const castleSettings = gui.addFolder("Castillo");
                castleSettings.open();

                castleSettings.add(options, "pisos",1,5,1);
                castleSettings.add(options, "ancho",0.3,1,0.01);
                castleSettings.add(options, "largo",0.3,1,0.01);
                castleSettings.add(options, "ladosMuralla",4,8,1);
                castleSettings.add(options, "alturaMuralla",0.8,1.5,0.01);


                var renderButton = { "Generar escena":function(){
                    castleFloors = options.pisos;
                    castleWidth = options.ancho;
                    castleLength = options.largo;
                    wallSides = options.ladosMuralla;
                    wallHeight = options.alturaMuralla;
                }};

                castleSettings.add(renderButton, "Generar escena");

                const sceneSettings = gui.addFolder("Escena");
                sceneSettings.open();


                sceneSettings.add(options, "anguloPuerta",0,90,0.1).onChange((val) => {
                    gateAngle = val;
                });
                sceneSettings.add(options, "rotacionCatapulta",0,360,1).onChange((val) => {
                    catapultRot = val;
                });
                sceneSettings.add(options, "ubicacionCatapulta",0,360,1).onChange((val) => {
                    catapultPos = val;
                });

                var shootCatapult = { "Disparar catapulta":function(){
                    anim = 0;
                }};

                sceneSettings.add(shootCatapult, "Disparar catapulta");

                var reloadCatapult = { "Recargar catapulta":function(){
                    loaded = 1;
                }};

                sceneSettings.add(reloadCatapult, "Recargar catapulta");

                gui.add(options, "camara", { "Orbital castillo": '1', "Orbital catapulta": '2', "Primera persona": '3'}).onChange((val) => {
                    camera = val;
                    if(camera == 1){
                        ratio = 4;                        
                        scrollSpeed = 0.5;
                    }
                    if(camera == 2){
                        ratio = 20;                        
                        scrollSpeed = 5;
                    }
                }).listen();

                gui.add(options, "renderizado", { "Texturas": '0', "Colores": '1', "Normales": '2'}).onChange((val) => {
                    renderType = val;
                    initShaders();
                });


            }

        
            function readSVGpath(name){

                var parser = new DOMParser();
                var path = document.getElementById(name+"Path").getAttribute("d");

                var pointData = path.split(' ');
                var controlPoints = [];

                for(var i=1; i < pointData.length; i++){
                    if(pointData[i] == "L"){
                        controlPoints.push([pointData[i-2]/100,-pointData[i-1]/100]);
                        controlPoints.push([pointData[i-2]/100,-pointData[i-1]/100]);
                        controlPoints.push([pointData[i+1]/100,-pointData[i+2]/100]);
                    }
                    else if(pointData[i] == "C"){
                        controlPoints.push([pointData[i-2]/100,-pointData[i-1]/100]);
                        controlPoints.push([pointData[i+1]/100,-pointData[i+2]/100]);
                        controlPoints.push([pointData[i+3]/100,-pointData[i+4]/100]);
                    }
                    else if((i == pointData.length - 3) && (pointData[pointData.length - 1] != "Z")){
                        controlPoints.push([pointData[i+1]/100,-pointData[i+2]/100]);
                    } 
                    else if (pointData[i] == "Z"){                        
                        controlPoints.push([pointData[i-2]/100,-pointData[i-1]/100]);
                        controlPoints.push([pointData[i-2]/100,-pointData[i-1]/100]);
                        controlPoints.push([pointData[1]/100,-pointData[2]/100]);
                        controlPoints.push([pointData[1]/100,-pointData[2]/100]);
                    }
                }

                return controlPoints;

            }

            function createWindows(height, width, zCoord=0) {

                var ventanas = [];

                var lengthWindowsAmount = Math.trunc((castleLength-windowSeparation)/(windowSeparation+width));
                var lengthDelta = (castleLength-windowSeparation)%(windowSeparation+width);

                var widthWindowsAmount = Math.trunc((castleWidth-windowSeparation)/(windowSeparation+width));
                var widthDelta = (castleWidth-windowSeparation)%(windowSeparation+width);

                for(var i=1; i<=lengthWindowsAmount; i++){
                    ventana = new Window([0, 102, 102],height,width,castleWidth+0.02,0,0);
                    ventana.rotateZ(Math.PI/2);
                    ventana.translate(0,i*windowSeparation+width/2+(i-1)*width-castleLength/2+lengthDelta/2,zCoord);
                    ventanas.push(ventana);
                }

                for(var i=1; i<=widthWindowsAmount; i++){
                    ventana = new Window([0, 102, 102],height,width,castleLength+0.02,0,0);
                    ventana.translate(0,i*windowSeparation+width/2+(i-1)*width-castleWidth/2+widthDelta/2,zCoord);
                    ventanas.push(ventana);
                }

                return ventanas;

            }

            function createDetails(zCoord=0){

                var bloques = [];

                bloqueD1 = new Block([255, 204, 102],0.02,0.02,castleLength);
                bloqueD1.setTexture(textures.marble);
                bloqueD1.translate(0,castleWidth/2,zCoord);

                bloqueD2 = new Block([255, 204, 102],0.02,0.02,castleLength);
                bloqueD2.setTexture(textures.marble);
                bloqueD2.translate(0,-castleWidth/2,zCoord);

                bloqueD3 = new Block([255, 204, 102],0.02,0.02,castleWidth);
                bloqueD3.setTexture(textures.marble);
                bloqueD3.rotateZ(Math.PI/2);
                bloqueD3.translate(0,castleLength/2,zCoord);

                bloqueD4 = new Block([255, 204, 102],0.02,0.02,castleWidth);
                bloqueD4.setTexture(textures.marble);
                bloqueD4.rotateZ(Math.PI/2);
                bloqueD4.translate(0,-castleLength/2,zCoord);

                bloques.push(bloqueD1);
                bloques.push(bloqueD2);
                bloques.push(bloqueD3);
                bloques.push(bloqueD4);

                return bloques;

            }

            function drawCastle(){

                var castleHeight = castleFloors/4;

                techo1 = new Roof([0, 51, 102]);
                techo1.translate(0,0,castleHeight*9);

                techo2 = new Roof([0, 51, 102]);
                techo2.translate(0,0,castleHeight*9);

                techo3 = new Roof([0, 51, 102]);
                techo3.translate(0,0,castleHeight*9);

                techo4 = new Roof([0, 51, 102]);
                techo4.translate(0,0,castleHeight*9);

                torreC1 = new TowerC([255, 255, 204],castleHeight*2,[techo1]);
                torreC1.translate(castleLength/2,castleWidth/2,-castleHeight/2);
                torreC1.scale(0.15);

                torreC2 = new TowerC([255, 255, 204],castleHeight*2,[techo2]);
                torreC2.translate(-castleLength/2,castleWidth/2,-castleHeight/2);
                torreC2.scale(0.15);

                torreC3 = new TowerC([255, 255, 204],castleHeight*2,[techo3]);           
                torreC3.translate(castleLength/2,-castleWidth/2,-castleHeight/2);
                torreC3.scale(0.15);

                torreC4 = new TowerC([255, 255, 204],castleHeight*2,[techo4]);
                torreC4.translate(-castleLength/2,-castleWidth/2,-castleHeight/2);
                torreC4.scale(0.15);

                roof = new Block([0, 51, 102],castleLength*0.9,castleWidth*0.9,castleHeight*2,0.5,0);
                roof.setTexture(textures.tiles);
                roof.translate(0,0,castleHeight-castleHeight/3.1);
                roof.scale(0.2);
                roof.rotateY(Math.PI/2);

                var children = [roof];

                var children = children.concat([torreC1,torreC2,torreC3,torreC4]);
                for(i=0; i<castleFloors; i++){
                    children = children.concat(createWindows(0.08,0.08,((1+(i*2))*castleHeight/(castleFloors*2))-castleHeight/2));
                    if(i>0){
                        children = children.concat(createDetails(i*castleHeight/castleFloors-castleHeight/2));
                    }
                }

                bloqueC = new Block([255, 255, 204],castleHeight,castleWidth,castleLength,0,0,children);
                bloqueC.setTexture(textures.marble);

                bloqueC.translate(0,0,0.25+castleHeight/2);

                castillo = new Transformable([bloqueC]);

                castillo.scale(0.7);
                

                return castillo;
            }

            function drawWalls(ratio=6){

                var angle = 2*Math.PI/wallSides;
                var minY = 10000;
                var fase = 0;
                var objects = [];
                var points = [];
                var pathPoints = [];

                for(var i=1;i<=wallSides;i++){

                    var x = Math.cos(angle*i-((1/2+wallSides/4)*angle))*ratio;
                    var y = Math.sin(angle*i-((1/2+wallSides/4)*angle))*ratio;

                    if(y < minY) {minY = y;}

                    torre = new Tower([0, 102, 102],wallHeight);
                    torre.translate(x,y,0);
                    torre.scale(0.7);

                    objects.push(torre);
                    points.push([x,y]);
                }

                pathPoints.push(points[0]);

                for(var i=0;i<wallSides-1;i++){

                    pathPoints.push(points[i]);
                    pathPoints.push(points[i+1]);
                    pathPoints.push(points[i+1]);

                }

                objects.push(new Wall([0, 102, 102],pathPoints,wallHeight-0.3,0.6,0,0,false));

                murallaP1 = new Wall([0, 102, 102],[[1,points[0][1]],[1,points[0][1]],points[0],points[0]],wallHeight-0.3,0.6,0,0,true);
                murallaP2 = new Wall([0, 102, 102],[points[wallSides-1],points[wallSides-1],[-1,points[wallSides-1][1]],[-1,points[wallSides-1][1]]],wallHeight-0.3,0.6,0,0,true);

                bloqueP1 = new Block([0, 102, 102],0.2,3,wallHeight*4.5,0.01,0);
                bloqueP1.setTexture(textures.brick);
                bloqueP1.translate(1.7,0,1.5);
                bloqueP1.rotateY(Math.PI/2);
                bloqueP2 = new Block([0, 102, 102],0.2,3,wallHeight*4.5,0.01,0);
                bloqueP2.setTexture(textures.brick);
                bloqueP2.translate(-1.7,0,1.5);
                bloqueP2.rotateY(Math.PI/2);
                bloqueP3 = new Block([0, 102, 102],wallHeight*0.4,3,3.6,0,0);
                bloqueP3.setTexture(textures.brick);
                bloqueP3.translate(0,0,wallHeight*3.4);
                bloquePuerta = new Block([102, 61, 0],0.2,wallHeight*3,3.2,0,0);
                bloquePuerta.setTexture(textures.wood);
                bloquePuerta.translate(0,0,1.4);
                bloquePuerta.translate(0,-1,-1);
                bloquePuerta.rotateX(gateAngle*Math.PI/180);
                bloquePuerta.translate(0,0,1);
                bloquePuerta.rotateX(Math.PI/2);

                puerta = new Transformable([bloqueP1,bloqueP2,bloqueP3,bloquePuerta]);
                puerta.translate(0,minY,0);
                puerta.scale(0.6);

                objects.push(murallaP1);
                objects.push(murallaP2);
                objects.push(puerta);

                pared = new Transformable(objects);

                pared.translate(0,0,0.18);
                pared.scale(0.1);

                return pared;

            }

            function shootProjectile(projectile){

                var startVec = vec4.create();
                var endVec = vec4.create();

                mat4.getTranslation(startVec,start);
                mat4.getTranslation(endVec,end);

                var speed = vec3.fromValues((endVec[0] - startVec[0])*7, (endVec[1] - startVec[1])*7, (endVec[2] - startVec[2])*7);

                var m = mat4.create();

                mat4.translate(m,m,[endVec[0]+speed[0]*s,endVec[1]+speed[1]*s,endVec[2]+speed[2]*s-(1/2)*0.98*(s**2)]);
                mat4.scale(m,m,[0.02,0.02,0.02]);

                projectile.setPosMatrix(m);

                s += 0.25;

            }

            function drawCatapult(){

                municion = new Sphere([163, 194, 194]);
                municion.setTexture(textures.stone);
                municion.scale(0.4*loaded);
                municion.translate(0,0,1.2);

                proyectil = new Sphere([163, 194, 194]);
                proyectil.setTexture(textures.stone);
                proyectil.scale(0.4*shot);

                if (shot == 1){
                    shootProjectile(proyectil);
                } 

                if(s == 5){
                    shot = 0;
                    s = 0;
                }

                cabeza = new Block([102, 68, 0],0.2,1.2,1.2,0,0,[municion]);
                cabeza.setTexture(textures.wood);
                cabeza.translate(-2.5,0,0.15);

                sostenCP1 = new Block([102, 68, 0],0.03,0.2,0.4,0.01,0);
                sostenCP1.setTexture(textures.wood);
                sostenCP1.translate(0.2,0,-0.1);
                sostenCP1.rotateY(Math.PI/2);
                sostenCP2 = new Block([102, 68, 0],0.03,0.2,0.4,0.01,0);
                sostenCP2.setTexture(textures.wood);
                sostenCP2.translate(-0.2,0,-0.1);
                sostenCP2.rotateY(Math.PI/2);
                contraPeso = new Block([117, 163, 163],0.4,0.6,0.6,0,0);
                contraPeso.setTexture(textures.stone);
                contraPeso.translate(0,0,-0.5);

                ejeCP = new Cylinder([51, 34, 0],0.08,0.08,0.5,0,0,[sostenCP1,sostenCP2,contraPeso]);
                ejeCP.setTexture(textures.wood);
                ejeCP.translate(2.8,0,0);
                ejeCP.rotateZ(Math.PI/2);
                ejeCP.rotateX(-Math.PI*((Math.sin(anim))*1/3+1/6));

                pala = new Block([102, 68, 0],0.2,0.2,6,0.03,0, [ejeCP, cabeza]);
                pala.setTexture(textures.wood);
                pala.translate(0,1.6,0.2);
                pala.rotateZ(-Math.PI/2);

                ejeP = new Cylinder([51, 34, 0],0.25,0.25,2,0,0, [pala]);
                ejeP.setTexture(textures.wood);
                ejeP.translate(0,0,0.7);
                ejeP.rotateZ(Math.PI/2);
                ejeP.rotateX(Math.PI*((Math.sin(anim))*1/3+1/6));
                sosten1 = new Block([102, 68, 0],0.1,0.7,2.4,0.05,0);
                sosten1.setTexture(textures.wood);
                sosten1.translate(0,0.8,0);
                sosten1.rotateY(Math.PI/2);
                sosten1.rotateX(Math.PI/2);
                sosten2 = new Block([102, 68, 0],0.1,0.7,2.4,0.05,0);
                sosten2.setTexture(textures.wood);
                sosten2.translate(0,-0.8,0);
                sosten2.rotateY(Math.PI/2);
                sosten2.rotateX(Math.PI/2);
                sosten = new Transformable([sosten1,sosten2,ejeP]);
                sosten.translate(0.6,0,1.2);

                ruedaD1 = new Cylinder([102, 68, 0],0.4,0.4,0.15,0,0);
                ruedaD1.setTexture(textures.stone);
                ruedaD1.translate(1.35,0,0);
                ruedaD2 = new Cylinder([102, 68, 0],0.4,0.4,0.15,0,0);
                ruedaD2.setTexture(textures.stone);
                ruedaD2.translate(-1.35,0,0);
                ejeD = new Cylinder([51, 34, 0],0.05,0.05,3,0,0, [ruedaD1,ruedaD2]);
                ejeD.setTexture(textures.wood);
                ejeD.translate(1.2,0,0);
                ejeD.rotateZ(Math.PI/2);

                ruedaT1 = new Cylinder([102, 68, 0],0.4,0.4,0.15,0,0);
                ruedaT1.setTexture(textures.stone);
                ruedaT1.translate(1.35,0,0);
                ruedaT2 = new Cylinder([102, 68, 0],0.4,0.4,0.15,0,0);
                ruedaT2.setTexture(textures.stone);
                ruedaT2.translate(-1.35,0,0);
                ejeT = new Cylinder([51, 34, 0],0.05,0.05,3,0,0, [ruedaT1,ruedaT2]);
                ejeT.setTexture(textures.wood);
                ejeT.translate(-1.2,0,0);
                ejeT.rotateZ(Math.PI/2);

                catapulta = new Block([102, 68, 0],0.2,2.5,3.5,0,0,[ejeD,ejeT,sosten]);
                catapulta.setTexture(textures.wood);
                catapulta.rotateZ(catapultPos*Math.PI/180);
                catapulta.translate(1.5,1.5,0.03);
                catapulta.rotateZ(catapultRot*Math.PI/180+Math.PI*1/4);
                catapulta.scale(0.06);

                return {catapulta, proyectil};

            }
            
            function drawScene(){

                setupVertexShaderMatrix();
                controls();

                agua = new Plane([102, 217, 255]);
                agua.setTexture(textures.water);
                agua.translate(0,0,-0.1);
                agua.rotateX(-Math.PI/2);

                puente = new Block([92, 214, 92],0.2,2,4,0,0);
                puente.setTexture(textures.wood);
                puente.scale(0.15);
                puente.rotateZ(Math.PI/2);
                puente.translate(-7.5,0,0.8);

                plataforma = new Platform([92, 214, 92],[drawCastle(),drawWalls(6),puente]);
                plataforma.translate(0,0,-0.2);

                terreno = new Terrain([92, 214, 92],[agua]);
                terreno.rotateZ(Math.PI*22.5/180);

                cat = drawCatapult();

                escena = new Transformable([terreno,plataforma,cat.catapulta,cat.proyectil]);

                escena.draw(mat4.create(),mat4.create());

                if(anim == 0 && loaded == 1 && shot == 0){
                    start = municion.getCompletePosMatrix();
                }

                if(anim<5){
                    if(anim == 1 && loaded == 1 && shot == 0){
                        end = municion.getCompletePosMatrix();
                        loaded = 0;
                        shot = 1;
                    } 
                    t = 1;
                } else if(anim==5){
                    t = 0.001;
                } else if (anim>5.1 && anim<6){
                    t = 0.01;
                } else{
                    t = 0;
                }

                anim += t;

            }

 

            function controls(){

                var deltaX=0;
                var deltaY=0;

                if(isMouseDown){

                    if (previousClientX) deltaX = mouse.x - previousClientX;
                    if (previousClientY) deltaY = mouse.y - previousClientY;

                    previousClientX = mouse.x;
                    previousClientY = mouse.y;

                    alpha = alpha + deltaX * speedFactor;
                    beta = beta + deltaY * speedFactor;

                    if(camera == 3){
                        maxBeta = Math.PI;
                        minBeta = 0;
                    } else{
                        maxBeta = Math.PI/2;
                        minBeta = 0;
                    }

                    if (beta>maxBeta) beta=maxBeta;
                    if (beta<minBeta) beta=minBeta;

                }


                mat4.identity(viewMatrix);
                mat4.identity(normalMatrix);

                if(camera == 1 || camera == 2){
                    mat4.translate(viewMatrix,viewMatrix,[0,0, -ratio]);
                    mat4.rotateX(viewMatrix,viewMatrix, -beta);
                    mat4.rotateZ(viewMatrix,viewMatrix, alpha);

                    if (camera==2){
                        catapultPosMat = catapulta.getPosMatrix();
                        inverse = mat4.create();
                        mat4.invert(inverse,catapultPosMat);
                        mat4.mul(viewMatrix,viewMatrix,inverse);
                        mat4.mul(normalMatrix,viewMatrix,catapultPosMat);
                        
                    } else{
                        mat4.mul(normalMatrix,viewMatrix,modelMatrix);
                    }

                }

                if(camera == 3){

                    forward = vec4.fromValues(0,0.1,0,1);
                    right = vec4.fromValues(0.1,0,0,1);

                    var ang = - fpRotation.z - alpha;
                    var m = mat4.create();
                    mat4.rotateZ(m,m,ang);

                    vec4.transformMat4(forward,forward,m);
                    vec4.transformMat4(right,right,m);

                    mat4.rotateX(viewMatrix,viewMatrix, -beta);
                    mat4.rotateZ(viewMatrix,viewMatrix, -ang);
                    mat4.translate(viewMatrix,viewMatrix,[fpPosition.x,fpPosition.y+5,-0.1]);

                    mat4.mul(normalMatrix,viewMatrix,modelMatrix);

                }


                mat4.invert(normalMatrix,normalMatrix);
                mat4.transpose(normalMatrix,normalMatrix);


            }
            
            function tick(){

                requestAnimationFrame(tick);
                drawScene();

            }

            window.onload=initWebGL;

        </script>


    </body>
</html>
